# Targets to Achieve :-

1. Should include all kinds of code - read a .asm file
2. Timing between each line in the pipeline diagram - a simulation
3. Colours for stalls, forwarding etc.
4. Ensure that memory access takes 2/3 cycles
5. More instruction need to be incorporated.
6. Plots - Can be made here 
7. NOPS handling
Possible plots - 
The performance statistics generated by the corrected MIPS processor simulation (from the array sum program in the first code) provide valuable insights into the processor’s behavior. These stats can be visualized to better understand the impact of architectural features like delayed branches and multi-cycle memory access. Below, I’ll identify the relevant statistics, suggest suitable plot types, and provide a Python script to generate one of the plots using the data from a simulation run. I’ll also explain why certain plots are meaningful and how they relate to the processor’s performance.

Performance Statistics Available
From the corrected code, the simulation outputs the following statistics:

Total Clock Cycles: The total number of cycles taken to execute the program.
Total Instructions Executed: The number of instructions that complete execution (reach the WB stage).
Total Stalls Due to Memory: The number of cycles where the pipeline is stalled due to multi-cycle memory operations (lw or sw).
Stalls Due to Loads: The subset of memory stalls caused specifically by load instructions (lw).
Delayed Branches Taken: The number of branch (beq) or jump (j) instructions where the branch was taken, triggering a delay slot.
Branch Delay Slot Effectiveness: Reported as 100% in the code (since all delay slots are executed, filled with nop), but could be interpreted as the number of delay slot cycles utilized.
Cycles Wasted Due to Memory Delays: Equal to memory_stalls, representing cycles where the pipeline was idle due to memory latency.
These metrics quantify the efficiency of the pipeline, the impact of memory latency, and the effectiveness of the delayed branch mechanism.

Possible Plots and Their Insights
Given these statistics, several types of plots can be generated to visualize performance. Here are the most meaningful options, along with their purpose and suitability:

Pie Chart: Breakdown of Cycle Types
What: Shows the proportion of total clock cycles spent on:
Instruction Execution: Estimated as total_instructions (assuming each instruction takes at least one cycle to complete).
Memory Stalls: From memory_stalls (includes both load and store stalls).
Branch Delay Slots: From delayed_branches (each taken branch contributes one delay slot cycle).
Why: Highlights how much time is spent productively (executing instructions) versus unproductively (stalling or executing nop in delay slots).
Insight: Reveals the impact of memory latency and branch delays on overall performance. For example, a large slice for memory stalls suggests memory access is a bottleneck.
Suitability: Ideal for a single simulation run to understand cycle distribution.
Bar Chart: Stall Breakdown
What: Compares:
Load Stalls (load_stalls).
Store Stalls (computed as memory_stalls - load_stalls).
Non-Stall Cycles (computed as total_clock_cycles - memory_stalls).
Why: Breaks down stalls by type to show whether loads or stores contribute more to delays.
Insight: Helps identify whether load latency (2 cycles) or store latency (3 cycles) is more detrimental, guiding potential optimizations (e.g., prioritizing load caching).
Suitability: Useful for analyzing memory performance in a single run.
Bar Chart: Instructions vs. Stalls vs. Delay Slots
What: Plots:
Total Instructions Executed.
Total Memory Stalls.
Delayed Branches Taken (as a proxy for delay slot cycles).
Why: Compares the volume of useful work (instructions executed) against sources of inefficiency (stalls and delay slots).
Insight: Shows how much the program’s execution is slowed by architectural features, indicating whether memory latency or branch handling is a bigger issue.
Suitability: Good for a quick comparison within a single run.
Line Plot: Performance Across Multiple Runs
What: Plots one or more stats (e.g., total_clock_cycles, memory_stalls, instructions_executed) across different program inputs or configurations (e.g., varying array sizes or memory latencies).
Why: Shows trends in performance as the workload changes.
Insight: Reveals scalability issues, such as whether memory stalls grow disproportionately with program size.
Suitability: Requires multiple simulation runs with different parameters, which the original code doesn’t directly support without modification.
Stacked Bar Chart: Cycle Composition Over Time
What: For each cycle (or a subset), stacks contributions from IF, ID, EX, MEM, WB stages, with stalls highlighted (e.g., MEM stage showing lw (2) or sw (3)).
Why: Visualizes pipeline activity and stalls temporally, showing when and why the pipeline slows down.
Insight: Pinpoints specific cycles where memory stalls disrupt flow, useful for debugging or optimizing instruction scheduling.
Suitability: Complex to generate from the current log and less practical for summary stats, as it requires per-cycle data parsing.
Given the statistics provided by the original code, the Pie Chart and Bar Chart (Stall Breakdown) are the most straightforward and insightful for a single simulation run, as they directly use the aggregated stats. A line plot would require multiple runs, which isn’t supported by the current code without significant changes. The stacked bar chart is too granular for the summary stats provided.

Chosen Plot: Pie Chart for Cycle Breakdown
I’ll generate a Pie Chart to visualize the breakdown of total clock cycles into:

Instruction Execution Cycles: Approximated as total_instructions, assuming each instruction contributes to pipeline progress.
Memory Stall Cycles: From memory_stalls.
Branch Delay Slot Cycles: From delayed_branches, as each taken branch executes one delay slot.
This plot is chosen because:

It’s simple to create using the existing stats.
It clearly shows the relative impact of stalls and delay slots on performance.
It’s meaningful for the array sum program, which has frequent memory operations (lw, sw) and branches (beq, j).
Assumptions for Plotting
Since the original code doesn’t explicitly break down every cycle’s contribution, I’ll make these assumptions:

Instruction Execution Cycles: Use total_instructions as a baseline, representing cycles where instructions progress through the pipeline.
Memory Stall Cycles: Use memory_stalls directly, as these are cycles where the pipeline is halted.
Branch Delay Slot Cycles: Use delayed_branches, as each taken branch adds one delay slot cycle (filled with nop in the program).
Total Clock Cycles: Use total_clock_cycles to ensure the sum of components is consistent, adjusting for overlap:
Some cycles may involve both instruction execution and delay slots, so I’ll prioritize stalls and delay slots, then attribute remaining cycles to instruction execution.
Formula: instruction_cycles = total_clock_cycles - memory_stalls - delayed_branches.
This approximation simplifies the visualization while capturing the main sources of cycle usage.

Sample Data
To create the plot, I need sample values. Based on a typical run of the array sum program (which iterates 10 times to sum an array, with lw in the loop and one sw at the end), let’s assume the following stats from a simulation run:

Total Clock Cycles: 130 (approximate, based on prior runs).
Total Instructions Executed: 73 (10 iterations × 7 instructions per loop + initial setup + final store).
Total Stalls Due to Memory: 21 (e.g., 10 lw × 2 cycles each + 1 sw × 3 cycles, minus 1 cycle per operation since the first cycle is counted in execution).
Delayed Branches Taken: 11 (10 j + 1 beq taken to exit the loop).
Stalls Due to Loads: 20 (10 lw × 2 cycles, minus 1 per load).
Cycles Wasted Due to Memory Delays: 21 (same as memory_stalls).
Branch Delay Slot Effectiveness: 100% (not directly plotted).
For the pie chart:

Memory Stall Cycles: 21.
Branch Delay Slot Cycles: 11.
Instruction Execution Cycles: 130 - 21 - 11 = 98 (adjusted to account for cycles not spent in stalls or delay slots).
These values are illustrative but realistic for the program’s structure. If you have specific output stats from running the code, I can use those instead.
